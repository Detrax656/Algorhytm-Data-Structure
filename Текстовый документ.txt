Python:
Список:

fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] # Создание списка с элементами
# примеры операций
fruits.count('apple') # подсчет колличества элементов
fruits.index('banana') # вывести номер элемента
# Создание списка с помощью генератора списков
squares = [x**2 for x in range(1, 6)]
print(squares)  # [1, 4, 9, 16, 25]


Стэк:

stack = []

# append() function to push element in the stack
stack.append('a')
stack.append('b')
stack.append('c')

print('Initial stack')
print(stack)

# pop() function to pop  element from stack in LIFO order
print('\nElements popped from stack:')
print(stack.pop())
print(stack.pop())
print(stack.pop())

print('\nStack after elements are popped:')
print(stack)

C++:
Список:

#include <iostream>
#include <list>
#include <iterator>

using namespace std;

int main() {
  list <int> my_list;
  list <int> list_merge = {7, 8, 9}; // Добавляет существующему списку еще один.

  for (int i = 0; i < 2; i++) {
    for (int j = 1; j < 6; j++) {
      my_list.push_back(i); // добавили 10 элементов
    }
  }

Стэк:

#include <iostream>
#include <stack>


int main() {
    // Создание стека целых чисел
    std::stack<int> numbers;

    // Добавление элементов в стек
    numbers.push(1);
    numbers.push(2);
    numbers.push(3);

    // Вывод вершины стека
    std::cout << "Top of the stack: " << numbers.top() << std::endl;

    // Удаление вершины стека
    numbers.pop();

    // Проверка стека на пустоту
    if (!numbers.empty()) {
        std::cout << "Stack is not empty." << std::endl;
    } else {
        std::cout << "Stack is empty." << std::endl;
    }

    return 0;
}

Java:
Список:

ArrayList<String> list = new ArrayList<>(); 
list.add("Hello"); # Добавляет новый элемент в конец списка
# Добавление всех элементов collection в список начиная с индекса index
ArrayList<String> secondList = new ArrayList<>();
secondList.addAll(list);
System.out.println("Первое добавление: " + secondList);
secondList.addAll(1, list);
System.out.println("Второе добавление в середину: " + secondList);

Стэк:

# MyStack хранит элементы типа T. Внутри класса объявляем массив stackArray для хранения элементов и переменную top для отслеживания индекса последнего элемента.
# Метод push добавляет элемент в вершину стека, метод pop удаляет и возвращает элемент из вершины стека.
public class MyStack<T> {
private T[] stackArray;
private int top;

public MyStack(int capacity) {
stackArray = (T[]) new Object[capacity];
top = -1;
}

public void push(T item) {
if (top == stackArray.length - 1) {
throw new IllegalStateException("Stack overflow");
}
stackArray[++top] = item;
}

public T pop() {
if (top == -1) {
throw new IllegalStateException("Stack underflow");
}
return stackArray[top--];
}

доступ к эедементам или синтьаксис или инициализация

























